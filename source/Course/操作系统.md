# 操作系统

[toc]

[蒋岩岩老师空间 jyy yyds!](https://space.bilibili.com/202224425)

南京大学 [操作系统：设计与实现](https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498) 听课笔记

## 操作系统概述

### 为什么学操作系统

提到了数学的发展与时代的发展

提到了数学，接着掏出了sympy这个python库来解积分题，太酷炫了，我也要学

我们的“编程力量”尚未完全觉醒：我们还有很多每天都在用的东西还不能自己写出来。为了打通自己的任督二脉，理解各种东西背后的原理并且联系起来。

虽然各种工业级别的软件我们一个人写不出来，但是我们可以摸到一个它的雏形。学习操作系统，变得真正地强。

### 什么是操作系统

programs！

老师说：国内教材都要下严格的定义，但是一个定义要是滴水不漏的话，那这个定义就没有用了。（这个定义就变得味同嚼蜡了）

![image-20220701174006148](操作系统.assets/image-20220701174006148.png)

“管理软硬件资源，为程序提供服务”的程序  。

这个定义给的很哲学，首先有了目的才有了操作系统：操作系统如何从一开始变成现在这样的？

从上世纪的真空管超大计算机开始，出现了延迟线内存，然后用汇编这些。

40年代就没有操作系统。50年代出现更小更快的逻辑门和更大的磁芯内存，出现了卡片打孔的程序（所以那时候必须要画流程图）。

60年代，有了更大的内存，可以把多个程序放到内存里， 然后CPU的速度比打印机快，CPU空闲下来了就可以去跑其他程序。这个时候的操作系统可以控制多个程序交替进行（multiprograming）。有了进程的概念，要隔离进程，多了中断机制，时钟中断和调度策略。

70年代，基本上有了现代操作系统。UNIX诞生走向完善。

今天的操作系统：虚拟化硬件资源，为程序运行提供服务的软件【更复杂的非对称多处理器和内存，更多的设备和资源，复杂的应用需求和应用环境】

三个基本问题：服务谁？为程序提供什么服务？如何实现操作系统提供的服务？

### 怎么学操作系统

1. 是一个合格的操作系统用户：使用Linux，不怕使用任何命令行工具，不怕写代码读代码
   - 学会使用正确的工具
   - 找对正确的材料：用Google/GitHub/StackOverflow
   - 改用命令行就用命令行，该用IDE就用ide
   - sympy，sage，z3，rich这些神奇的python库
2. 学会写代码：**命令行+浏览器=全世界！**
3. 边听课边写代码

## 操作系统上的程序

前置课程：计算机系统基础，学到什么？整个计算机系统和数字逻辑电路有契合性。

状态机（状态=寄存器保存的值，初始状态= RESET ，迁移=组合逻辑电路计算寄存器下一周期的值）

**状态机**由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。有限状态机简写为FSM（Finite State Machine），主要分为2大类：

- 第一类，若输出只和状态有关而与输入无关，则称为Moore状态机

- 第二类，输出不仅和状态有关而且和输入有关系，则称为Mealy状态机

学习 vi 的用法，理解示例给出的代码（使用宏定义的语法特性）

```c
#include <stdio.h>
#include <unistd.h>

#define REGS_FOREACH(_)  _(X) _(Y)
#define RUN_LOGIC        X1 = !X && Y; \
                         Y1 = !X && !Y;
#define DEFINE(X)        static int X, X##1;
#define UPDATE(X)        X = X##1;
#define PRINT(X)         printf(#X " = %d; ", X);

int main() {
  REGS_FOREACH(DEFINE);
  while (1) { // clock
    RUN_LOGIC;
    REGS_FOREACH(PRINT);
    REGS_FOREACH(UPDATE);
    putchar('\n'); sleep(1);
  }
}
```

使用 vim 打开文件并粘贴代码，用`:!gcc %`编译文件，用`:!gcc % && ./a.out`编译并运行。注意用vi打开没有语法高亮，用vim打开才有。vim中，按 i 进入编辑模式，esc 可以退出到命令模式。

用命令`gcc -E a.c`可以把文件 a.c 代码中的宏全部展开。老师还用到 tmux 一边显示代码一边输入命令。

上面的代码是一个数字电路的模拟器，接着老师用管道把另一个代码丢到 python 写的一个七段数码管模拟程序，实现了一个图形化的 012012 数码管变化，python 的这个程序读入A=0/1 来控制A号管亮与不亮。**把一个程序的输出当作另一个程序的输入**

### 什么是程序？

数字系统是状态机，所有的程序运行在数字系统上，因此程序也是状态机。

c程序的状态是什么？也是状态机。

老师拿出了递归的汉诺塔程序，配合 gdb 食用，在 gdb 里面 step （输入 s），每一次 step 都改变了栈堆上的内容，也就是一个状态。c语言程序是有很多栈帧 (stack frame) 组成的，每个函数调用都创建一个栈帧，函数返回就是把顶上的栈帧删掉。

这边没上过前置课程已经傻了，老师用 gdb 切换到汇编视角

程序有一个初始状态，如果没有输入，会是一个确定性的系统，但是有随机数指令，会使状态机产生分叉。所有状态机的状态会构成一个图，会有环会一直在图里面跑。

syscall ：系统调用，让程序把所有状态都交给操作系统，实现与操作系统中的其他对象的交互

所有操作系统上的程序：本质还是计算，但是还需要在适当的时候用 syscall 把任务交给操作系统。



### 构造最小的 Hello, World - 编译器与二进制代码语义对应

用c语言写一个最小的 Hello, World实际上是很大的，还有很多冗余，能不能构造一个最小的 printf 来打印 Hello, World

老师用`gcc -c a.c`仅编译，然后用`objdump -d a.o`来查看汇编代码，然后用`ld a.o`来链接生成可执行文件，这个过程中老师把 main 函数换成了一个`void _start()`的东西，之后发现 segment fault 的错误，程序在 retq 这个指令之后出错

只要是状态机就可以观察，用 gdb 来观察程序这个状态机，要想解决异常退出（让状态机停下来），就要使用 syscall 。（syscall 函数在 <sys/syscall.h> 这个文件中）

老师用汇编的方式去写出了这个东西输出 Hello, World 。我们要学会读手册……

编译器就是把c代码视角的状态机 转化成 二进制代码视角的状态机。什么是编译正确$$C =compile(S)$$：就是c代码上所有不可优化的部分都被对应到汇编代码上。老师甚至展示了编译器是如何优化c代码的，然后如何设置一个 barrier 来消灭这个优化。

### 操作系统中的一般程序

程序 = 计算 + syscall 

操作系统收编了所有的软硬件资源，只能用操作系统来访问这些资源，在我们的应用眼里操作系统就是 syscall ，syscall 就是一个 API ，被用来访问所有操作系统控制的对象。

问：程序的第一条指令是什么，答：问gdb，会告诉你它是什么，然而他是一个加载器背后有很复杂的过程，老师甚至修改了加载器的效果，这里懵了。

老师强调 strace 这个工具，来观察程序进行了那些 syscall 。强调计算机世界是完全确定的。

感觉这节课基本上全是 hack 的技术，这节课主要回答了什么是程序。强调使用的工具： gcc, binutils, gdb, strace



